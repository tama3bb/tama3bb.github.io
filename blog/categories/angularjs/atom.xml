<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: AngularJS | AngularJS Ninja]]></title>
  <link href="http://angularjsninja.com/blog/categories/angularjs/atom.xml" rel="self"/>
  <link href="http://angularjsninja.com/"/>
  <updated>2014-10-17T19:00:41+09:00</updated>
  <id>http://angularjsninja.com/</id>
  <author>
    <name><![CDATA[Akihito Tamagawa]]></name>
    <email><![CDATA[tama3bb@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AngularJS 1.3 新機能 ngModelOptions]]></title>
    <link href="http://angularjsninja.com/blog/2014/10/17/angularjs-1.3-ngmodeloptions/"/>
    <updated>2014-10-17T18:57:38+09:00</updated>
    <id>http://angularjsninja.com/blog/2014/10/17/angularjs-1.3-ngmodeloptions</id>
    <content type="html"><![CDATA[<p><a href="/blog/2014/10/14/angularjs-1.3.0-released/">AngularJS 1.3.0</a> で導入された新機能から、ng-model でのモデル更新を調整できる directive の <a href="https://docs.angularjs.org/api/ng/directive/ngModelOptions">ngModelOptions</a> について取り上げます。</p>

<h2>ngModelOptions</h2>

<p>すぐに覚えて使ってみるべきオプションは、<code>updateOn</code> と <code>debounce</code> ですね。</p>

<h3>updateOn</h3>

<p><code>updateOn</code> は、input などの UI に対するどのイベントの場合にモデルを更新するかを指定できます。</p>

<p>``` javascript
&lt;input type=&ldquo;text&rdquo; name=&ldquo;userName&rdquo;</p>

<pre><code>ng-model="user.name"
ng-model-options="{ updateOn: 'blur' }"&gt;
</code></pre>

<p>```</p>

<p>これで、blur（フォーカスが外れる）イベントまでは、この input で入力値を変更してもモデルに反映されなくなります。blur イベントではじめてモデル更新されます。</p>

<h3>debounce</h3>

<p><code>debounce</code> は、モデルの更新を待機しておく時間を、ミリ秒単位で指定できます。</p>

<p>``` javascript
&lt;input type=&ldquo;text&rdquo; name=&ldquo;userName&rdquo;</p>

<pre><code>ng-model="user.name"
ng-model-options="{ debounce: 1000 }"&gt;
</code></pre>

<p>```</p>

<p>これで、変更から 1 秒（1,000 ミリ秒）経過後にモデルが更新されるようになります。変更から 1 秒経過するまでに別の変更があった場合には、待機中の更新処理は破棄されます。</p>

<!-- more -->


<h3>複数オプションの指定</h3>

<p>ngModelOptions は、以下のように複数のオプションを一度に指定できます。この指定は、モデル更新を 500 ミリ秒遅延させるが、blur イベントのみすぐに更新という意味になります。</p>

<p><code>javascript
ng-model-options="{ updateOn: 'default blur', debounce: {'default': 500, 'blur': 0} }"
</code></p>

<h3>使用上の注意</h3>

<p>ngModelOptions で <code>updateOn</code> や <code>debounce</code> を利用すると、input フィールドの入力値と、実際のモデルの値が異なっている状態が増えます。そのため、モデルのほうを変更するときには、関係する input フィールドに対して <code>$rollbackViewValue</code> を呼び出すことで、モデルの値と一致させ、遅延されている更新処理をキャンセルさせます。</p>

<p><code>$rollbackViewValue</code> function は、userForm.userName.$rollbackViewValue() のように参照して呼び出せます。</p>

<h3>submit イベントで更新完了</h3>

<p>待機中の更新処理は、<code>submit</code> イベントによって即座に実行されます。<code>ngClick</code> イベントはモデル更新前となるので、更新後のモデルにアクセスしたい場合には <code>ngSubmit</code> を利用します。</p>

<h3>ngModelOptions は子孫要素にも適用</h3>

<p>ngModelOptions は、input 要素に直接指定するだけでなく、祖先要素となる <code>form</code> などに指定することもできます。</p>

<h3>その他のオプション</h3>

<ul>
<li><code>allowInvalid</code></li>
</ul>


<p>invalid なモデル値を許容するか、undefined（デフォルト動作）にするかを boolean で指定。</p>

<ul>
<li><code>getterSetter</code></li>
</ul>


<p>getters/setters として <code>ngModel</code> に function をバインドするかを boolean で指定。</p>

<ul>
<li><code>timezone</code></li>
</ul>


<p><code>&lt;input type="date"&gt;</code> <code>&lt;input type="time"&gt;</code> の Date インスタンスを読み書きするときに利用するタイムゾーンを指定する。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS 1.3 新機能 ワンタイムバインディング]]></title>
    <link href="http://angularjsninja.com/blog/2014/10/16/angularjs-1.3-one-time-binding/"/>
    <updated>2014-10-16T08:40:32+09:00</updated>
    <id>http://angularjsninja.com/blog/2014/10/16/angularjs-1.3-one-time-binding</id>
    <content type="html"><![CDATA[<p><a href="/blog/2014/10/14/angularjs-1.3.0-released/">AngularJS 1.3.0</a> で導入された新機能から、ワンタイムバインディング (<a href="https://docs.angularjs.org/guide/expression#one-time-binding">One-time binding</a>) について取り上げます。</p>

<h2>One-time binding</h2>

<p>値が変わることのないデータまでも双方向データバインドされて、digest loop のたびに繰り返し変更監視されることで性能が劣化しやすかった大規模な AngularJS アプリケーションでの問題を解消できます。</p>

<p>1 回で使い捨てするデータバインドを定義できるようになり、監視 (watch) 対象を減らして digest loop を高速化し、アプリケーションの表示や操作の応答速度を高められる機能です。</p>

<p>One-time binding を指定すると、undefined のままである間は監視対象となり続け、digest loop の結果 undefined でなくなった時点で監視対象から外れます。null となった場合でも監視対象から外れます。</p>

<h4>使い方</h4>

<p><code>::</code> を付けるだけです。</p>

<!-- more -->


<p>
``` javascript
// {{ &hellip; }} の例
{{::user.name}}</p>

<p>// 属性の例</p>

<p><div ng-bind="::user.name"></p>

<p>// ng-repeat の例
<li ng-repeat="result in ::results">{{::result.title}}</li>
```
</p>

<p>ng-repeat への指定は配列に対して有効であって、配列に格納されているオブジェクトのプロパティ個々に対しては、それぞれで必要に応じて <code></code> などと one-time binding を指定することになります。</p>

<h2>Bindonce</h2>

<p>「そもそもこういう性能改善系の機能こそ JavaScript の実行速度が遅い IE 8 でこそ必要なのに、AngularJS 1.3 では IE 8 サポートがドロップされたし…。IE 8 をサポートしなきゃいけない自分には AngularJS 1.3 リリースなんかで盛り上がれやしないよ！」</p>

<p>とお嘆きのあなたには、<a href="https://github.com/Pasvaz/bindonce">Bindonce</a> です！</p>

<p>しばらく IE 8 をサポートし続けていくのであれば、この Bindonce の導入を検討しましょう。AngularJS 1.3.0 の新機能 One-time binding と同じように性能を改善できます。</p>

<h4>使い方</h4>

<p><code>bindonce.js</code> (<code>bindonce.min.js</code>) ファイルを読み込み、<code>angular.module('app', ['pasvaz.bindonce'])</code> というように <code>'pasvaz.bindonce'</code> を依存モジュールとして定義し、以下のようにコードを記述して使います。</p>

<p>``` javascript
<ul>
  <li bindonce ng-repeat="person in Persons"></p>

<pre><code>&lt;a bo-href="'#/people/' + person.id"&gt;&lt;img bo-src="person.imageUrl"&gt;&lt;/a&gt;
&lt;a bo-href="'#/people/' + person.id" bo-text="person.name"&gt;&lt;/a&gt;
&lt;p bo-class="{'cycled':person.generated}" bo-html="person.description"&gt;&lt;/p&gt;
</code></pre>

<p>  </li>
</ul>
<code>``
</code>bindonce<code>とか、</code>bo-*` で始まる directive に注目してください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS: Migrating from 1.2 to 1.3 日本語訳]]></title>
    <link href="http://angularjsninja.com/blog/2014/10/15/migrating-from-1.2-to-1.3-in-Japanese/"/>
    <updated>2014-10-15T08:24:48+09:00</updated>
    <id>http://angularjsninja.com/blog/2014/10/15/migrating-from-1.2-to-1.3-in-Japanese</id>
    <content type="html"><![CDATA[<p><a href="http://angularjsninja.com/blog/2014/10/14/angularjs-1.3.0-released/">AngularJS 1.3.0 がリリース</a>されたので、移行ガイド (<a href="https://docs.angularjs.org/guide/migration#migrating-from-1-2-to-1-3">Migrating from 1.2 to 1.3</a>) のほうも日本語訳しておきました。</p>

<hr />

<h2>Migrating from 1.2 to 1.3</h2>

<h3>$parse</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/77ada4c82d6b8fc6d977c26f3cdb48c2f5fbe5a5">prevent invocation of Function&rsquo;s bind, call and apply</a></em></p>

<p>angular 式の中では function の <code>.bind</code> <code>.call</code> <code>.apply</code> を呼び出せなくなりました。既存 function の振る舞いを予測できない形で変更させないようにするためです。</p>

<p><em><a href="https://github.com/angular/angular.js/commit/6081f20769e64a800ee8075c168412b21f026d99">forbid <code>__proto__</code> properties in angular expressions</a></em></p>

<p>angular 式の中では (deprecated) <code>__proto__</code> プロパティは動作しなくなりました。</p>

<p><em><a href="https://github.com/angular/angular.js/commit/48fa3aadd546036c7e69f71046f659ab1de244c6">forbid <code>__{define,lookup}{Getter,Setter}__</code> properties</a></em></p>

<p>angular 式の中では <code>__{define,lookup}{Getter,Setter}__</code> を利用できなくなりました。必要な場合は、危険でなくなるようにラップ／バインドして scope オブジェクトを通して利用してください。</p>

<p><em><a href="https://github.com/angular/angular.js/commit/528be29d1662122a34e204dd607e1c0bd9c16bbc">forbid referencing Object in angular expressions</a></em></p>

<p>angular 式の中では <code>Object</code> を利用できなくなりました。<code>Object.keys</code> が必要な場合は scope でアクセスできるようにしてください。</p>

<!-- more -->


<h3>Angular.copy</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/b59b04f98a0b59eead53f6a53391ce1bbcbe9b57">preserve prototype chain when copying objects</a></em></p>

<p>コピー元オブジェクトの prototype をコピー先オブジェクトに適用するように <code>angular.copy</code> を変更しています。以前はプロトタイプチェーンのプロパティを直接コピーしていました。</p>

<p>コピー先オブジェクトの <code>hasOwnProperty</code> プロパティだけを iterate しても、prototype からのプロパティは含まれなくなり、より適切な振る舞いになっていると考えています。</p>

<p>もしアプリケーションがこの振る舞いに依存している場合は、オブジェクト（と継承プロパティ）のすべてのプロパティを <code>hasOwnProperty</code> でフィルタしないように iterate してください。</p>

<p><strong>この変更は IE 8 で動作しない機能を使っていることに注意してください。</strong>もし IE 8 で動作させたい場合は <code>Object.create</code> と <code>Object.getPrototypeOf</code> の polyfill を使ってください。</p>

<h3>core</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/bdfc9c02d021e08babfbc966a007c71b4946d69d">drop the toBoolean function</a></em></p>

<p><code>f</code> <code>0</code> <code>false</code> <code>no</code> <code>n</code> <code>[]</code> は falsy として扱われず、JavaScript の falsy 値である <code>false</code> <code>null</code> <code>undefined</code> <code>NaN</code> <code>0</code> <code>""</code> のみ falsy として扱われるようになりました。</p>

<h3>$compile</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/2cde927e58c8d1588569d94a797e43cdfbcedaf9">always error if two directives add isolate-scope and new-scope</a></em></p>

<p>1 つの要素に isolate scope と別の scope をリクエストするとエラーとなるように変更されました。変更前は、isolate でない scope の directive の次に、isolate な scope の directive という順でコンパイラが適用する場合には、2 つの directive が child scope と isolate scope をリクエストすることが可能でした。</p>

<p>順番にかかわらず、コンパイラはエラーとするようになりました。</p>

<p><code>$compile:multidir</code> エラーとなるようであれば、同じ要素で複数の directive が isolate と isolate でない scope をリクエストしていないかを確認し、コードを修正してください。</p>

<h3>NgModel</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/1be9bb9d3527e0758350c4f7417a4228d8571440">ensure pattern and ngPattern use the same validator</a></em></p>

<p>ng-pattern (<code>ng-pattern="exp"</code>) あるいは pattern 属性 (<code>pattern=""</code>) で angular 式が使われて文字列として評価される場合、validator は正規表現オブジェクトのリテラル (<code>/abc/i</code>) として文字列を解析せず、文字列全体を正規表現としてしまいます。つまり、フラグが正規表現として正しく扱われません。この制限を回避するために、正規表現オブジェクトを angular 式の値に使用してください。</p>

<p>``` javascript
// before
$scope.exp = &lsquo;/abc/i&rsquo;;</p>

<p>// after
$scope.exp = /abc/i;
```</p>

<h3>Scope</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/8c6a8171f9bdaa5cdabc0cc3f7d3ce10af7b434d">change Scope#id to be a simple number</a></em></p>

<p>Scope#$id は文字列ではなく数値型となりました。この id は主にデバッグ目的で利用されており、他に影響を与えないものと考えています。</p>

<h3>forEach</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/55991e33af6fece07ea347a059da061b76fc95f5">cache array length</a></em></p>

<p>forEach は配列の初期数だけ iterate するようになり、iteration 中に配列に追加されたアイテムは forEach の対象となりません。</p>

<p>この変更により、forEach が Array#forEach の動作により近くなりました。</p>

<h3>jqLite</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/a196c8bca82a28c08896d31f1863cf4ecd11401c">data should store data only on Element and Document nodes</a></em></p>

<p>テキスト／コメントのノードにも jqLite のデータをセットできていましたが、jQuery と同じように要素とドキュメントのノードのみとなりました。</p>

<h3>$resource</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/d3c50c845671f0f8bcc3f7842df9e2fb1d1b1c40">allow props beginning with $ to be used on resources</a></em></p>

<p><code>$resource</code> がプロパティを削除する挙動を期待している場合、手動で行う必要があります。</p>

<h3>angular.toJson</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/c054288c9722875e3595e6e6162193e0fb67a251">only strip properties beginning with $$, not $</a></em></p>

<p><code>toJson</code> がプロパティを削除する挙動を期待していた場合、手動で行う必要があります。</p>

<h3>$compile</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/eec6394a342fb92fba5270eee11c83f1d895e9fb">deprecate <code>replace</code> directives</a></em></p>

<p>要素を置き換える directive 定義の <code>replace</code> フラグは、Angular の次のメジャーバージョンで廃止されます。この機能は扱いにくい問題（属性をどのようにマージするか、など）があり、この機能が解決できることよりも多くの問題をもたらしています。また、Web Components では DOM にカスタム要素が存在するのが一般的です。</p>

<h3>$parse</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/fa6e411da26824a5bae55f37ce7dbb859653276d">remove deprecated promise unwrapping</a></em></p>

<p>promise をアンラップする機能は 1.2.0-rc.3 で既に削除されています。</p>

<h3>Scope</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/82f45aee5bd84d1cc53fb2e8f645d2263cdaacbc">$broadcast and $emit should set event.currentScope to null</a></em></p>

<p><code>$broadcast</code> と <code>$emit</code> は、イベントの伝播 (propagation) を終了した時点でイベントの <code>currentScope</code> プロパティを null にリセットするようになりました。<code>currentScope</code> プロパティに非同期にアクセスするコードは、<code>targetScope</code> を利用するようにしてください。</p>

<h3>jqLite</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/d71dbb1ae50f174680533492ce4c7db3ff74df00">stop patching individual jQuery methods</a></em></p>

<p>jQuery の <code>detach()</code> メソッドは <code>$destroy</code> イベントをトリガーしなくなりました。要素に付けた Angular データを破棄したい場合は <code>remove()</code> を利用してください。</p>

<h3>$http</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/ad4336f9359a073e272930f8f9bcd36587a8648f">remove deprecated responseInterceptors functionality</a></em></p>

<p>これまでは response interceptor を以下のようにも登録できました。</p>

<p>``` javascript
// register the interceptor as a service
$provide.factory(&lsquo;myHttpInterceptor&rsquo;, function($q, dependency1, dependency2) {
  return function(promise) {</p>

<pre><code>return promise.then(function(response) {
  // do something on success
  return response;
}, function(response) {
  // do something on error
  if (canRecover(response)) {
    return responseOrNewPromise
  }
  return $q.reject(response);
});
</code></pre>

<p>  }
});</p>

<p>$httpProvider.responseInterceptors.push(&lsquo;myHttpInterceptor&rsquo;);
```</p>

<p>v1.1.4（4ae46814）で導入された API では以下のようになります。</p>

<p>``` javascript
$provide.factory(&lsquo;myHttpInterceptor&rsquo;, function($q) {
  return {</p>

<pre><code>response: function(response) {
  // do something on success
  return response;
},
responseError: function(response) {
  // do something on error
  if (canRecover(response)) {
    return responseOrNewPromise
  }
  return $q.reject(response);
}
</code></pre>

<p>  };
});</p>

<p>$httpProvider.interceptors.push(&lsquo;myHttpInterceptor&rsquo;);
```</p>

<p>この API の詳細は <a href="https://docs.angularjs.org/api/ng/service/$http#interceptors">interceptors</a> で確認してください。</p>

<h3>injector</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/c0b4e2db9cbc8bc3164cedc4646145d3ab72536e">invoke config blocks for module after all providers</a></em></p>

<p>config ブロックは provider 登録の前に呼び出されていたため動作を制御可能でしたが、常に config よりも前に provider 登録されるようになったために動作を制御できなくなりました。</p>

<p>例：</p>

<p>以前は、以下のようなコードが動作していました。</p>

<p>``` javascript
angular.module(&lsquo;foo&rsquo;, [])
.provider(&lsquo;$rootProvider&rsquo;, function() {
  this.$get = function() { &hellip; }
})
.config(function($rootProvider) {
  $rootProvider.dependentMode = &ldquo;B&rdquo;;
})
.provider(&lsquo;$dependentProvider&rsquo;, function($rootProvider) {
  if ($rootProvider.dependentMode === &ldquo;A&rdquo;) {</p>

<pre><code>this.$get = function() {
  // Special mode!
}
</code></pre>

<p>  } else {</p>

<pre><code>this.$get = function() {
  // something else
}
</code></pre>

<p>  }
});
```</p>

<p><code>$rootProvider</code> と <code>$dependentProvider</code> の間にある config ブロックがアプリケーションの動作を変更できていましたが、これは今では 1 つのモジュール内では実現できなくなりました。</p>

<h3>ngModelOptions</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/adfc322b04a58158fb9697e5b99aab9ca63c80bb">move debounce and updateOn logic into NgModelController</a></em></p>

<p>このコミットは <code>NgModelController</code> の API を変更しています。</p>

<ul>
<li><code>$setViewValue(value)</code> &ndash; このメソッドは <code>$viewValue</code> を変更しますが、これまでとは異なり、<code>$modelValue</code> の変更をすぐにはコミットしなくなり、関連する <code>ngModelOptions</code> directive で指定されたトリガーによってコミットされるようになりました。<code>ngModelOptions</code> に <code>debounce</code> で遅延させるトリガーが指定されている場合には、変更のコミットはさらに延期されます。</li>
<li><code>$cancelUpdate()</code> &ndash; <code>$rollbackViewValue()</code> に名前が変更されましたが、同じ機能のままで、<code>$viewValue</code> の値を <code>$lastCommittedViewValue</code> に戻し、ペンディング中の debounce されている更新と、input への再 render の処理をキャンセルします。</li>
</ul>


<p><code>$cancelUpdate()</code> を利用しているコードは、以下の例に従って移行してください。</p>

<p>前：</p>

<p>``` javascript
$scope.resetWithCancel = function (e) {
  if (e.keyCode == 27) {</p>

<pre><code>$scope.myForm.myInput1.$cancelUpdate();
$scope.myValue = '';
</code></pre>

<p>  }
};
```</p>

<p>後：</p>

<p>``` javascript
$scope.resetWithCancel = function (e) {
  if (e.keyCode == 27) {</p>

<pre><code>$scope.myForm.myInput1.$rollbackViewValue();
$scope.myValue = '';
</code></pre>

<p>  }
}
```</p>

<h3>$interpolate</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/88c2193c71954b9e7e7e4bdf636a2b168d36300d">split .parts into .expressions and .separators</a></em></p>

<p><code>$interpolate</code> に返される function は <code>.parts</code> 配列を持たなくなりました。</p>

<p>代わりに、2 つの配列を持つようになります。</p>

<ul>
<li><code>.expressions</code> &ndash; interpolate されるテキストの expression 配列。</li>
<li><code>.separators</code> &ndash; interpolation 間を区切る文字列の配列で、この配列はマージしやすくするために、<strong>常に</strong> <code>.expressions</code> 配列より 1 アイテム長くなっています。</li>
</ul>


<h3>$animate</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/1cb8584e8490ecdb1b410a8846c4478c6c2c0e53">insert elements at the start of the parent container instead of at the end</a></em></p>

<p><code>$animate</code> は、親コンテナの最後の要素とする after パラメータをデフォルトとしなくなり、after が指定されていない場合には新しい要素を最初の子要素として挿入するようになりました。</p>

<p>既存のコードを更新する場合には、<code>$animate.enter()</code> または <code>$animate.move()</code> のすべてのインスタンスを</p>

<p><code>$animate.enter(element, parent);</code></p>

<p>から</p>

<p><code>$animate.enter(element, parent, angular.element(parent[0].lastChild));</code></p>

<p>に変更してください。</p>

<p><em><a href="https://github.com/angular/angular.js/commit/1bebe36aa938890d61188762ed618b1b5e193634">make CSS blocking optional for class-based animations</a></em></p>

<p>トランジションを利用する（class-add や class-remove のような）セットアップ CSS class ベースのアニメーションコードは、スタイルがすぐに適用されるように空の transition 値を与えなければなりません。つまり、アニメーションのコードがセットアップ class で定義されているスタイルを適用し、その CSS class で <code>transition:0s none</code> の値が存在しない限りは即座に適用されません。この状況はトランジションがベース CSS クラスに存在し、アニメーションが開始されているケースのことです。</p>

<p>前：</p>

<p><code>css
.animated.my-class-add {
  opacity:0;
  transition:0.5s linear all;
}
.animated.my-class-add.my-class-add-active {
  opacity:1;
}
</code></p>

<p>後：</p>

<p><code>css
.animated.my-class-add {
  transition:0s linear all;
  opacity:0;
}
.animated.my-class-add.my-class-add-active {
  transition:0.5s linear all;
  opacity:1;
}
</code></p>

<p>詳細は ngAnimate のドキュメントで確認してください。</p>

<h3>$compile</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/299b220f5e05e1d4e26bfd58d0b2fd7329ca76b1">add support for $observer deregistration</a></em></p>

<p><code>attr.$observe</code> の呼び出しはオブザーバー function ではなく、登録解除の function を返すようになりました。以下の例に従ってコードを移行してください。</p>

<p>前：</p>

<p>``` javascript
directive(&lsquo;directiveName&rsquo;, function() {
  return {</p>

<pre><code>link: function(scope, elm, attr) {
  var observer = attr.$observe('someAttr', function(value) {
    console.log(value);
  });
}
</code></pre>

<p>  };
});
```</p>

<p>後：</p>

<p>``` javascript
directive(&lsquo;directiveName&rsquo;, function() {
  return {</p>

<pre><code>link: function(scope, elm, attr) {
  var observer = function(value) {
    console.log(value);
  };

  attr.$observe('someAttr', observer);
}
</code></pre>

<p>  };
});
```</p>

<h3>$httpBackend</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/6680b7b97c0326a80bdccaf0a35031e4af641e0e">don&rsquo;t error when JSONP callback called with no parameter</a></em></p>

<p>空のレスポンスに対する JSONP の動作が変更されました。以前は JSONP レスポンスが空の場合にはエラーとみなされていましたが、適切にイベントをリスンするようになりました。</p>

<h3>build</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/eaa1d00b24008f590b95ad099241b4003688cdda">remove IE8 target from all test configs</a></em></p>

<p>IE 8 はサポートされなくなりました。</p>

<h3>input</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/46bd6dc88de252886d75426efc2ce8107a5134e9">support types date, time, datetime-local, month, week</a></em></p>

<p>type が date、time、datetime-local、month、week の input では、モデルとして常に <code>Date</code> オブジェクトが必須となりました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS 1.3.0 リリース]]></title>
    <link href="http://angularjsninja.com/blog/2014/10/14/angularjs-1.3.0-released/"/>
    <updated>2014-10-14T12:44:47+09:00</updated>
    <id>http://angularjsninja.com/blog/2014/10/14/angularjs-1.3.0-released</id>
    <content type="html"><![CDATA[<p>AngularJS 1.3.0 がリリースされました！</p>

<p>ということで、公式ブログの記事『<a href="http://angularjs.blogspot.jp/2014/10/angularjs-130-superluminal-nudge.html">AngularJS 1.3.0 &ndash; superluminal-nudge</a>』を日本語訳しておきました。</p>

<hr />

<h2>AngularJS 1.3.0 &ndash; superluminal-nudge</h2>

<p>8 か月にわたり、2,000 を超えるコミット、19 のベータと 6 のリリースキャンディデートを経て、遂に AngularJS 1.3.0 superluminal-nudge をリリースしました！</p>

<p>このリリースには、注目すべき機能が多く含まれています。</p>

<ul>
<li><a href="https://docs.angularjs.org/guide/expression#one-time-binding">One-time bindings</a> &ndash; <code>::</code> を付けることによって、内挿 (interpolate) が 1 度となり、それ以降は監視 (watch) されなくなる。</li>
<li><a href="https://docs.angularjs.org/api/ngAria">ngAria</a> &ndash; デフォルトで（アクセシビリティに関して）アクセシブルなカスタムコンポーネントを実装するための新しいモジュール</li>
<li><a href="https://docs.angularjs.org/api/ngMessages">ngMessages</a> &ndash; フォームの妥当性に対するフィードバック（メッセージ）を実装しやすくする新しいディレクティブ</li>
<li><a href="https://docs.angularjs.org/api/ng/directive/ngModelOptions">ngModelOptions</a> &ndash; バインドされたモデルの振る舞いをカスタマイズしやすくするディレクティブ。例：debounce （モデル更新のタイミング制御）、getter-setter スタイルのモデル、blur 時のモデル更新など。</li>
<li><a href="https://docs.angularjs.org/error/$injector/strictdi">Strict DI</a> &ndash; 簡略した DI シンタックスを利用していて minify できないコードを見つけることができるオプション</li>
</ul>


<!-- more -->


<p>このリリースには、400 を超えるバグフィックスに、1,000 近いドキュメントの改善が含まれています。また、<a href="https://docs.angularjs.org/api/ng/type/ngModel.NgModelController">custom form controls</a> や <a href="https://docs.angularjs.org/api/ngAnimate/service/$animate">animations</a> まわりの API を、明確で使いやすいように改善しています。</p>

<p>1.3.0 は大幅に性能が改善しています。メモリ消費量を抑え、DOM 操作の速度を高め、Angular アプリケーションの全体的な応答速度を改善しています。詳細については、GitHub の <a href="https://github.com/angular/angular.js/tree/master/benchmarks">benchmarks in the AngularJS source code</a> で確認していただけます。</p>

<p><a href="https://github.com/angular/angular.js/blob/master/CHANGELOG.md#130-superluminal-nudge-2014-10-13">Changelog on Github</a> では、変更点すべてのリストを確認できます。</p>

<p>多くの要望により、AngularJS は公式に npm でパッケージを公開しました。<code>npm install angular</code> で AngularJS 1.3.0 を取得できます。これにより、フロントエンド Web 開発のすばらしいツール類を利用しやすくなると期待しています。</p>

<p>Angular 1.2 を利用されている場合は、<a href="https://docs.angularjs.org/guide/migration#migrating-from-1-2-to-1-3">corresponding section of the migration docs</a> を参照し、breaking changes について意識しておいてください。そして、<a href="/blog/2013/12/15/angularjs-1.3-discontinues-support-for-ie8/">昨年 12 月にご案内していた</a>ように、AngularJS 1.3.0 は IE 8 をサポートしていません。これにより、IE 8 のサポートを続けていては可能でなかった大幅な改善と性能向上を実現しています。IE 8 のサポートを必要とするアプリケーションを開発していく場合には、ほぼすべての non-breaking fixes が含まれている最新の 1.2.x ブランチをご利用ください。</p>

<p>新しいバージョンの Angular をぜひ試していただき、もし不具合を発見された場合には <a href="https://github.com/angular/angular.js/issues">GitHub で submit issues</a> してください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[期間限定の対面企画]]></title>
    <link href="http://angularjsninja.com/blog/2014/10/11/angularjs-in-person/"/>
    <updated>2014-10-11T02:08:08+09:00</updated>
    <id>http://angularjsninja.com/blog/2014/10/11/angularjs-in-person</id>
    <content type="html"><![CDATA[<p>「AngularJS のこと対面で教えてよ！」というリクエストにお応えします。</p>

<p>ご希望あれば Twitter で <a href="https://twitter.com/tama3bb">@tama3bb</a> までご連絡ください。各日とも先着 1 名です。</p>

<h3>日時</h3>

<ul>
<li>2014/10/16（木） 16:00 &ndash; 18:00 （ご予約済み）</li>
<li>2014/10/17（金） 16:00 &ndash; 18:00</li>
<li>2014/10/24（金） 16:00 &ndash; 18:00</li>
<li>2014/10/31（金） 16:00 &ndash; 18:00</li>
<li>2014/11/ 7（金） 16:00 &ndash; 18:00</li>
<li>2014/11/14（金） 16:00 &ndash; 18:00</li>
</ul>


<!-- more -->


<h3>場所</h3>

<p>グランフロント大阪あたりのカフェ</p>

<h3>料金</h3>

<p>500 円（当日、カフェラテをご馳走してくださーい）</p>

<h3>内容</h3>

<p>AngularJS だけでなく、以下のような内容でしたらお話できます。</p>

<ul>
<li>JavaScript (AngularJS, jQuery, etc.)</li>
<li>HTML / CSS (Bootstrap, etc.)</li>
<li>Java</li>
<li>リモートワーク（歴 2 年）</li>
<li>フリーランス（歴 8 年）</li>
<li>英語学習（大昔ですが、TOEIC 915）</li>
<li>語学留学（アメリカ、フィリピン）</li>
<li>転職（退職経験 4 回）</li>
</ul>


<h3>キャンセル方法</h3>

<p>もともと梅田で晩に用事がある日ですので、当日の 16 時までにご連絡いただければドタキャンでも構いません。</p>
]]></content>
  </entry>
  
</feed>
