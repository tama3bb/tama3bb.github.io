<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: AngularJS | AngularJS Ninja]]></title>
  <link href="http://angularjsninja.com/blog/categories/angularjs/atom.xml" rel="self"/>
  <link href="http://angularjsninja.com/"/>
  <updated>2014-10-28T16:14:56+09:00</updated>
  <id>http://angularjsninja.com/</id>
  <author>
    <name><![CDATA[Akihito Tamagawa]]></name>
    <email><![CDATA[tama3bb@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[（日本語訳）ng-europe, Angular 1.3, and beyond]]></title>
    <link href="http://angularjsninja.com/blog/2014/10/28/ngeurope-angular1.3-and-beyond-in-japanese/"/>
    <updated>2014-10-28T16:12:47+09:00</updated>
    <id>http://angularjsninja.com/blog/2014/10/28/ngeurope-angular1.3-and-beyond-in-japanese</id>
    <content type="html"><![CDATA[<p>AngularJS 公式ブログの記事 <a href="http://angularjs.blogspot.jp/2014/10/ng-europe-angular-13-and-beyond.html">ng-europe, Angular 1.3, and beyond</a> を日本語訳しておきました。</p>

<hr />

<p>先週、パリで開催した <a href="http://ngeurope.org">ng-europe</a> において、Angular の過去、現在、そして未来について発表しました。このブログポストでは、重要なポイントとお知らせについてまとめています。</p>

<h2>Angular 1.3</h2>

<p>リリースしたばかりの新しい AngularJS 1.3 では、AngularJS 1.2 には無かった多くの機能と改善が含まれています。</p>

<ul>
<li>パフォーマンス：DOM 操作や digest など多くの処理が 3 &ndash; 4 倍高速化し、アプリケーションが軽快に動作します。</li>
<li>フォーム：シンプルな API となり、フォームバリデーションのコードを短く記述できます。</li>
<li>ARIA サポート：<a href="https://docs.angularjs.org/api/ngAria">ngAria</a> により、スクリーンリーダーなどの支援ソフトウェアをサポートする適切な ARIA 属性を追加・削除できます。</li>
<li>Material Design：ユーザインターフェイスデザインとインタラクションのための <a href="http://www.google.com/design/spec/material-design/introduction.html">Google&rsquo;s specification</a> をほぼ完全に機能するよう実装しています。詳しくは <a href="https://material.angularjs.org">material.angularjs.org</a> で。</li>
</ul>


<p>Web アプリケーションを実装しているなら、このバージョンを使ってください。Angular 1.x で構築された Google の 1,600 を超えるアプリケーションで、長期間にわたってこのバージョンを最上位としてサポートしていくことをコミットしています。</p>

<p>Angular 1.x で予定していた新機能と breaking changes については、一部の例外を除いて 2.0 に先送りし、新しい設計をベースに取り組んでいきます。PRs（プルリクエスト）のレビューと issues への返答を続けてはいますが、1.x については、機能よりも安定性、セキュリティ、性能をより重視していきます。</p>

<p>Angular 1.2 をお使いであれば、コードを 1.3 に移行する方法について <a href="https://docs.angularjs.org/guide/migration">migration instructions</a>（<a href="http://angularjsninja.com/blog/2014/10/15/migrating-from-1.2-to-1.3-in-Japanese/">日本語</a>）を確認してください。</p>

<!-- more -->


<h2>From 1.3 to 2.0: Angular&rsquo;s Next Step</h2>

<p>1 月に開催した <a href="http://ng-conf.org">ng-conf</a> の <a href="https://www.youtube.com/watch?v=r1A1VR0ibIQ">keynote</a> で、Angular 2 の計画について発表しました。それ以降の数か月にわたり、Angular にとっての次の進化となるステップについてブレインストーミングを繰り返してきました。3 月には<a href="http://angularjs.blogspot.jp/2014/03/angular-20.html">デザインドキュメントで考えを発表</a>し、フィードバックから Angular がどう使われ、どう使いたいと考えられているかを確認し、様々なアプローチ、プロトタイプ、ベンチマーク、デザインを繰り返し、ベストを求めてきました。</p>

<p>先週の <a href="http://ngeurope.org">ng-europe</a> の場で、このリサーチとプロトタイプによる Angular 2.0 のビジョンについて発表し、Angular が本物の Angular（DI、HTML ベースのテンプレート、ディレクティブ、テスタビリティ）となることを見ていただけたと思います。一方で、Angular を近年の Web プラットフォームのシフト（web components や module system など）に適用させ、Angular を著しく高速化して使いやすくするためには、1.x からの段階的なステップでは実現できず、それに伴うデザイン変更が生じることも見ていただきました。</p>

<p>具体的な変更点：</p>

<ul>
<li>Angular 1.x の controllers と templates を包含する統一されたコンポーネントモデルにより、概念 (concepts) と定型 (boilerplate) を減らして再利用性を高める。</li>
<li>scope の概念を見直してシンプルでわかりやすくし、コンポーネント間の責任分担を改善。</li>
<li>モジュール化されたモバイルファーストなデザインで、エンタープライズレベルのデスクトップアプリケーションのニーズまでスケール。 &ndash; 世界人口の 50 % を超える人々が、デスクトップではなくモバイルでインターネットに接続しており、モバイル向けのアプリケーションを開発しやすくしたいと考えています。一方で、エンタープライズ分野ではデスクトップ Web アプリケーションの重要性も残り続けます。</li>
<li>Web Components サポート。1.x での Web プラットフォームについての前提はもはや有効ではなく、対応させるために Angular を変更していきます。</li>
<li>ES6 (with easy transpilation to ES5) で構築。つまり、現在のブラウザで未来の JavaScript のコードを書き始めることができます。あるいは、ES5 で Angular 2 アプリケーションを実装することもできます。</li>
<li><a href="https://docs.google.com/presentation/d/1hr2IM-8G-0RzpB-WY8pLHvxqNggKPzUO0KvEv1IKPws/edit#slide=id.p">AtScript を導入</a>。TypeScript シンタックスと ES6 を拡張し、実行時の型とアノテーションを追加することで、大きなチームが大規模なアプリケーションを構築し、ドキュメント化することを支援します。ES6 と同じように、アプリケーションの構築に AtScript は必須ではありません。</li>
<li>Angular は jqLite や DOM ラッパーに依存しない。DOM は 2009 年以来大幅に改善しており、AngularJS がラッパーに依存する必要はなく、ラッパーを無くすことでパフォーマンスも向上します。必要であればディレクティブに jQuery や他の DOM ライブラリを使うこともできます。</li>
</ul>


<p>これらのアイデアの多くは、Angular 開発者との<a href="https://drive.google.com/#folders/0B7Ovm8bUYiUDR29iSkEyMk5pVUk">ディスカッション</a>によるもので、ディスカッションに加わってくださった開発者の方々にあらためて感謝します！ 安定と性能を重視した <a href="http://angularjs.blogspot.jp/2014/10/angularjs-130-superluminal-nudge.html">AngularJS 1.3 をリリース</a>（<a href="http://angularjsninja.com/blog/2014/10/14/angularjs-1.3.0-released/">日本語</a>）した今、Angular 2.0 の構築に向けて進んでいきます。</p>

<h2>What does this mean for me?</h2>

<p>Angular コミュニティこそが、Angular を素晴らしいものにしています。2.0 の計画を早期に共有することで、コンセプトから実際のコードにしていくためのディスカッションに、多くの方々が参加していただけるようにしています。開発者の方々からの協力を必要としており、考えをお伺いできることを楽しみにしています。GitHub で issues を発行していただくか、Twitter (<a href="https://twitter.com/bradlygreen">Brad</a>, <a href="https://twitter.com/IgorMinar">Igor</a>, <a href="https://twitter.com/briantford">Brian</a>, <a href="https://twitter.com/jeffbcross">Jeff</a>) や <a href="https://plus.google.com/+AngularJS/posts">Google+</a> でご連絡ください。ミートアップにお越しいただいたり、<a href="https://drive.google.com/#folders/0BxgtL8yFJbacMEZDc2NtWS1VZ1k">ミーティングノート</a>のフォロー・コメントもお願いします。</p>

<h2>When can I use Angular 2.0?</h2>

<p>現在の実験的な状態にある Angular 2.0 であれば、<a href="http://github.com/angular/angular">GitHub</a> と<a href="https://drive.google.com/#folders/0BxgtL8yFJbacMEZDc2NtWS1VZ1k">ミーティングノート</a>でフォローしていただけます。2.0 のコードで何かを構築するには早すぎ、プロジェクトはまだ本当に初期の段階です。まだリリース日を発表できるような状態ではありませんが、初期のバージョンを少しでも早くリリースできるよう進めています。</p>

<h2>How can I learn more about Angular 2.0?</h2>

<p>まだ非常に初期の段階ですが、まず ng-europe (<a href="https://twitter.com/ngEurope/status/525966523496955904">when they are available</a>) のビデオを見ていただくことから始められるのが一番です。特に、2 日間それぞれの Keynote と、Angular 2 Core のセッションです。</p>

<p>時間を掛けて、より深い内容を見ていただけるなら、すべての<a href="https://drive.google.com/#folders/0B7Ovm8bUYiUDR29iSkEyMk5pVUk">デザインドキュメントとリサーチ</a>に目を通してみてください。</p>

<p>コードは GitHub の <a href="https://github.com/angular/angular">angular/angular</a> リポジトリにありますが、まだ初期の段階であり、数か月のうちに続々と増えていくことになります。</p>

<p>最後に、パートナーによって公開されているリソースについても確認してください。ES6 と Angular 2.0 についての <a href="http://blogs.msdn.com/b/typescript/archive/2014/10/22/typescript-and-the-road-to-2-0.aspx">TypeScript のブログ記事</a>や、<a href="https://github.com/google/traceur-compiler">Traceur</a>、<a href="http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts">EcmaScript 6</a>、<a href="http://webcomponents.org/">Web Components</a> です。</p>

<h2>What about Migrating from 1.3 to 2.0?</h2>

<p>Angular 2 のゴールは、既存 API との後方互換性に縛られることなく、Web アプリケーションを構築するための最高のツールセットにすることです。Angular 2 の最初のバージョンに合わせて、Angular 1 ベースのアプリケーションからの移行パスについての作業を始めます。</p>

<p>Angular で Web アプリケーションを実装するために、たくさんの時間を投資して学習してくださっていることを知っています。核となる概念のほとんどを維持していきますので、Angular 2 においても同じ知識を活かして短期間で熟練していただけます。</p>

<h2>What&rsquo;s next?</h2>

<p>ng-europe は Angular コミュニティにとって素晴らしいイベントでした。プレゼンテーションやデモは素晴らしく、またそれ以上に、通路などで交わされたすべてのインフォーマルな会話が大切なものでした。そして今、発表したアイデアをリアルなものとしていくために、<a href="https://github.com/angular/angular/">ご参加ください</a>。2.0 が開発中の間は、Angular 1.3 で素晴らしいアプリケーションを構築してください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS カンファレンス（ng-europe 2014）のスライドまとめ]]></title>
    <link href="http://angularjsninja.com/blog/2014/10/24/slides-at-ngeurope-2014/"/>
    <updated>2014-10-24T10:05:33+09:00</updated>
    <id>http://angularjsninja.com/blog/2014/10/24/slides-at-ngeurope-2014</id>
    <content type="html"><![CDATA[<h2>Slides at ng-europe 2014</h2>

<p>10/22 〜 10/23 に、パリ（フランス）で AngularJS のカンファレンス <a href="http://ngeurope.org">ng-europe</a> が開催されていました。</p>

<p>捕捉できたスライドについてはリンクしています。抜けが多いですが、スライドを捕捉できしだい追加していきます。</p>

<h3>WEDNESDAY OCTOBER 22nd</h3>

<p>Igor Minar &amp; Brad Green &ndash; <a href="https://docs.google.com/presentation/d/1-M5U0B6JI2JKU2ibVmU-xKkR7a88Uz1ZN0pc2lEuGzE/edit#slide=id.p">Keynote</a></p>

<p>Jeff Cross &amp; Brian Ford &ndash; <a href="https://drive.google.com/file/d/0Bw6GBXhPGkUGcEVuQlFMQklnUTA/view">Angular 1.3</a></p>

<p>Andrew Joslin &ndash; Ionic Framework</p>

<p>Victor Berchet &amp; Rado Kirov &ndash; <a href="https://docs.google.com/presentation/d/1qKoCrd7YgwsRPT8z2e8ahsY-JZkP6-cXPfbDSLz_HgQ/pub?start=false&amp;loop=false&amp;delayms=3000&amp;slide=id.p">AngularDart under the hood</a></p>

<p>Vojta Jína &ndash; <a href="https://dl.dropboxusercontent.com/u/36607830/talks/2014-can-we-learn-from%20architects.pdf">Can We Learn from Architects?</a></p>

<p>Julien Bouquillon &ndash; <a href="http://blog.revolunet.com/ngeurope-angular-cordova/#1">Using AngularJS and Phonegap to build hybrid mobile applications</a></p>

<p>Thomas Burleson &amp; Max Lynch &ndash; <a href="http://angular-material.slides.com/tburleson/introducing-angular-material-design">Material Design</a></p>

<p>Pete Bacon Darwin &ndash; <a href="https://docs.google.com/presentation/d/10ROq66kEpcB8eEgSYxmzUB82Ydt2oS2kaO-sNodEMoY/pub?start=false&amp;loop=false&amp;delayms=3000&amp;slide=id.p">Dgeni &ndash; Documentation generation on steroids</a></p>

<p>Julie Ralph &amp; Chirayu Krishnappa &ndash; <a href="https://docs.google.com/presentation/d/1ITWsMDGd6ArrP6KbGRLLzS9f9NMnyqozIdjtaj0Ek2c/edit#slide=id.p">Protractor and the Testability API</a></p>

<p>Rob Eisenberg &ndash; <a href="http://www.slideshare.net/RobEisenberg/ngeurope-the-new-router">The new Router for AngularJS</a></p>

<p>Pawel Kozlowski &ndash; <a href="http://pkozlowski-opensource.github.io/ng-europe-2014/presentation/">ui-bootstrap</a></p>

<p>Matthieu Lux &ndash; <a href="https://github.com/Swiip/angular-from-scratch">Angular from scratch</a></p>

<p>Oliver Dore &ndash; <a href="http://www.slideshare.net/workandco/vx-ng-europe">Responsive Takes Flight: Building The First Responsive Airline Website</a></p>

<h3>WEDNESDAY OCTOBER 23rd</h3>

<p>Miško Hevery &ndash; <a href="https://docs.google.com/presentation/d/1hr2IM-8G-0RzpB-WY8pLHvxqNggKPzUO0KvEv1IKPws/mobilepresent?slide=id.g3e58cc2be_3300">Keynote</a></p>

<p>Igor Minar &amp; Tobias Bosch &ndash; <a href="https://docs.google.com/presentation/d/1XQP0_NTzCUcFweauLlkZpbbhNVYbYy156oD--KLmXsk/edit#slide=id.p">Angular 2.0 Core</a></p>

<p>Zack Brown &ndash; <a href="http://thomasstreet.com/ngeurope/">Famous Angular</a></p>

<p>Douglas Duteil &ndash; <a href="https://docs.google.com/presentation/d/1W-0qR2LDmdeAv_3uGC1w6HyB-8Zc6ANwx1WM5wJrsx0/edit#slide=id.g4e26e863f_179">Yet another way to animate in Angular</a></p>

<p>Martin Gontovnikas &ndash; <a href="http://mgonto.github.io/restangular20-ngeurope-talk/">Restangular 2.0: The future and beyond</a></p>

<p>Erik Arvidsson &amp; Vojta Jína &ndash; <a href="http://arv.github.io/ngeurope/#/">ES6 in Angular 2.0</a></p>

<p>Matias Niemelä &ndash; Animations (sequencer, web animations)</p>

<p>Lukas Ruebbelke &ndash; <a href="http://onehungrymind.com/slides/realtime-cage-dragon-with-firebase-angularjs-google.pdf">Be a Real Time Cage Dragon with AngularJS and Firebase</a></p>

<p>Carmen Popoviciu &amp; Pascal Precht &ndash; <a href="http://slidedeck.io/PascalPrecht/dont-stop-thinking-about-tomorrow">“Don’t stop thinking about tomorrow” &ndash; AngularJS and Web Components</a></p>

<p>Marcy Sutton &ndash; <a href="http://marcysutton.github.io/angular-a11y/#/">AngularJS Accessibility</a></p>

<p>Jeremy Elbourn &ndash; <a href="https://docs.google.com/presentation/d/1eOL6ZaT-WqqC5q5D_uwE2EJxKmdWmfmXkkD4T47iYHk/edit#slide=id.g4e203762d_065">Software Patterns and Design with AngularJS</a></p>

<p>Dave Smith &ndash; <a href="http://slides.com/djsmith/the-power-of-angular-q/#/">The Power of $q</a></p>

<p>Matias Woloski &amp; Martin Gontovnikas &ndash; <a href="https://speakerdeck.com/mgonto/make-your-spa-a-maximum-security-prison">Making your Angular app a maximum security prision</a></p>

<p>Ari Lerner &ndash; Building games with AngularJS</p>

<p>Brian Ford &ndash; <a href="https://docs.google.com/presentation/d/16RJPOvWMePMTkvDrugOakV9uyGFRMd3PZ3g5UofhfIY/edit#slide=id.p">Tooling</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS 1.3 新機能 ngModelOptions]]></title>
    <link href="http://angularjsninja.com/blog/2014/10/17/angularjs-1.3-ngmodeloptions/"/>
    <updated>2014-10-17T18:57:38+09:00</updated>
    <id>http://angularjsninja.com/blog/2014/10/17/angularjs-1.3-ngmodeloptions</id>
    <content type="html"><![CDATA[<p><a href="/blog/2014/10/14/angularjs-1.3.0-released/">AngularJS 1.3.0</a> で導入された新機能から、ng-model でのモデル更新を調整できる directive の <a href="https://docs.angularjs.org/api/ng/directive/ngModelOptions">ngModelOptions</a> について取り上げます。</p>

<h2>ngModelOptions</h2>

<p>すぐに覚えて使ってみるべきオプションは、<code>updateOn</code> と <code>debounce</code> ですね。</p>

<h3>updateOn</h3>

<p><code>updateOn</code> は、input などの UI に対するどのイベントの場合にモデルを更新するかを指定できます。</p>

<p>``` javascript
&lt;input type=&ldquo;text&rdquo; name=&ldquo;userName&rdquo;</p>

<pre><code>ng-model="user.name"
ng-model-options="{ updateOn: 'blur' }"&gt;
</code></pre>

<p>```</p>

<p>これで、blur（フォーカスが外れる）イベントまでは、この input で入力値を変更してもモデルに反映されなくなります。blur イベントではじめてモデル更新されます。</p>

<h3>debounce</h3>

<p><code>debounce</code> は、モデルの更新を待機しておく時間を、ミリ秒単位で指定できます。</p>

<p>``` javascript
&lt;input type=&ldquo;text&rdquo; name=&ldquo;userName&rdquo;</p>

<pre><code>ng-model="user.name"
ng-model-options="{ debounce: 1000 }"&gt;
</code></pre>

<p>```</p>

<p>これで、変更から 1 秒（1,000 ミリ秒）経過後にモデルが更新されるようになります。変更から 1 秒経過するまでに別の変更があった場合には、待機中の更新処理は破棄されます。</p>

<!-- more -->


<h3>複数オプションの指定</h3>

<p>ngModelOptions は、以下のように複数のオプションを一度に指定できます。この指定は、モデル更新を 500 ミリ秒遅延させるが、blur イベントのみすぐに更新という意味になります。</p>

<p><code>javascript
ng-model-options="{ updateOn: 'default blur', debounce: {'default': 500, 'blur': 0} }"
</code></p>

<h3>使用上の注意</h3>

<p>ngModelOptions で <code>updateOn</code> や <code>debounce</code> を利用すると、input フィールドの入力値と、実際のモデルの値が異なっている状態が増えます。そのため、モデルのほうを変更するときには、関係する input フィールドに対して <code>$rollbackViewValue</code> を呼び出すことで、モデルの値と一致させ、遅延されている更新処理をキャンセルさせます。</p>

<p><code>$rollbackViewValue</code> function は、userForm.userName.$rollbackViewValue() のように参照して呼び出せます。</p>

<h3>submit イベントで更新完了</h3>

<p>待機中の更新処理は、<code>submit</code> イベントによって即座に実行されます。<code>ngClick</code> イベントはモデル更新前となるので、更新後のモデルにアクセスしたい場合には <code>ngSubmit</code> を利用します。</p>

<h3>ngModelOptions は子孫要素にも適用</h3>

<p>ngModelOptions は、input 要素に直接指定するだけでなく、祖先要素となる <code>form</code> などに指定することもできます。</p>

<h3>その他のオプション</h3>

<ul>
<li><code>allowInvalid</code></li>
</ul>


<p>invalid なモデル値を許容するか、undefined（デフォルト動作）にするかを boolean で指定。</p>

<ul>
<li><code>getterSetter</code></li>
</ul>


<p>getters/setters として <code>ngModel</code> に function をバインドするかを boolean で指定。</p>

<ul>
<li><code>timezone</code></li>
</ul>


<p><code>&lt;input type="date"&gt;</code> <code>&lt;input type="time"&gt;</code> の Date インスタンスを読み書きするときに利用するタイムゾーンを指定する。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS 1.3 新機能 ワンタイムバインディング]]></title>
    <link href="http://angularjsninja.com/blog/2014/10/16/angularjs-1.3-one-time-binding/"/>
    <updated>2014-10-16T08:40:32+09:00</updated>
    <id>http://angularjsninja.com/blog/2014/10/16/angularjs-1.3-one-time-binding</id>
    <content type="html"><![CDATA[<p><a href="/blog/2014/10/14/angularjs-1.3.0-released/">AngularJS 1.3.0</a> で導入された新機能から、ワンタイムバインディング (<a href="https://docs.angularjs.org/guide/expression#one-time-binding">One-time binding</a>) について取り上げます。</p>

<h2>One-time binding</h2>

<p>値が変わることのないデータまでも双方向データバインドされて、digest loop のたびに繰り返し変更監視されることで性能が劣化しやすかった大規模な AngularJS アプリケーションでの問題を解消できます。</p>

<p>1 回で使い捨てするデータバインドを定義できるようになり、監視 (watch) 対象を減らして digest loop を高速化し、アプリケーションの表示や操作の応答速度を高められる機能です。</p>

<p>One-time binding を指定すると、undefined のままである間は監視対象となり続け、digest loop の結果 undefined でなくなった時点で監視対象から外れます。null となった場合でも監視対象から外れます。</p>

<h4>使い方</h4>

<p><code>::</code> を付けるだけです。</p>

<!-- more -->


<p>
``` javascript
// {{ &hellip; }} の例
{{::user.name}}</p>

<p>// 属性の例</p>

<p><div ng-bind="::user.name"></p>

<p>// ng-repeat の例
<li ng-repeat="result in ::results">{{::result.title}}</li>
```
</p>

<p>ng-repeat への指定は配列に対して有効であって、配列に格納されているオブジェクトのプロパティ個々に対しては、それぞれで必要に応じて <code></code> などと one-time binding を指定することになります。</p>

<h2>Bindonce</h2>

<p>「そもそもこういう性能改善系の機能こそ JavaScript の実行速度が遅い IE 8 でこそ必要なのに、AngularJS 1.3 では IE 8 サポートがドロップされたし…。IE 8 をサポートしなきゃいけない自分には AngularJS 1.3 リリースなんかで盛り上がれやしないよ！」</p>

<p>とお嘆きのあなたには、<a href="https://github.com/Pasvaz/bindonce">Bindonce</a> です！</p>

<p>しばらく IE 8 をサポートし続けていくのであれば、この Bindonce の導入を検討しましょう。AngularJS 1.3.0 の新機能 One-time binding と同じように性能を改善できます。</p>

<h4>使い方</h4>

<p><code>bindonce.js</code> (<code>bindonce.min.js</code>) ファイルを読み込み、<code>angular.module('app', ['pasvaz.bindonce'])</code> というように <code>'pasvaz.bindonce'</code> を依存モジュールとして定義し、以下のようにコードを記述して使います。</p>

<p>``` javascript
<ul>
  <li bindonce ng-repeat="person in Persons"></p>

<pre><code>&lt;a bo-href="'#/people/' + person.id"&gt;&lt;img bo-src="person.imageUrl"&gt;&lt;/a&gt;
&lt;a bo-href="'#/people/' + person.id" bo-text="person.name"&gt;&lt;/a&gt;
&lt;p bo-class="{'cycled':person.generated}" bo-html="person.description"&gt;&lt;/p&gt;
</code></pre>

<p>  </li>
</ul>
<code>``
</code>bindonce<code>とか、</code>bo-*` で始まる directive に注目してください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS: Migrating from 1.2 to 1.3 日本語訳]]></title>
    <link href="http://angularjsninja.com/blog/2014/10/15/migrating-from-1.2-to-1.3-in-Japanese/"/>
    <updated>2014-10-15T08:24:48+09:00</updated>
    <id>http://angularjsninja.com/blog/2014/10/15/migrating-from-1.2-to-1.3-in-Japanese</id>
    <content type="html"><![CDATA[<p><a href="http://angularjsninja.com/blog/2014/10/14/angularjs-1.3.0-released/">AngularJS 1.3.0 がリリース</a>されたので、移行ガイド (<a href="https://docs.angularjs.org/guide/migration#migrating-from-1-2-to-1-3">Migrating from 1.2 to 1.3</a>) のほうも日本語訳しておきました。</p>

<hr />

<h2>Migrating from 1.2 to 1.3</h2>

<h3>$parse</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/77ada4c82d6b8fc6d977c26f3cdb48c2f5fbe5a5">prevent invocation of Function&rsquo;s bind, call and apply</a></em></p>

<p>angular 式の中では function の <code>.bind</code> <code>.call</code> <code>.apply</code> を呼び出せなくなりました。既存 function の振る舞いを予測できない形で変更させないようにするためです。</p>

<p><em><a href="https://github.com/angular/angular.js/commit/6081f20769e64a800ee8075c168412b21f026d99">forbid <code>__proto__</code> properties in angular expressions</a></em></p>

<p>angular 式の中では (deprecated) <code>__proto__</code> プロパティは動作しなくなりました。</p>

<p><em><a href="https://github.com/angular/angular.js/commit/48fa3aadd546036c7e69f71046f659ab1de244c6">forbid <code>__{define,lookup}{Getter,Setter}__</code> properties</a></em></p>

<p>angular 式の中では <code>__{define,lookup}{Getter,Setter}__</code> を利用できなくなりました。必要な場合は、危険でなくなるようにラップ／バインドして scope オブジェクトを通して利用してください。</p>

<p><em><a href="https://github.com/angular/angular.js/commit/528be29d1662122a34e204dd607e1c0bd9c16bbc">forbid referencing Object in angular expressions</a></em></p>

<p>angular 式の中では <code>Object</code> を利用できなくなりました。<code>Object.keys</code> が必要な場合は scope でアクセスできるようにしてください。</p>

<!-- more -->


<h3>Angular.copy</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/b59b04f98a0b59eead53f6a53391ce1bbcbe9b57">preserve prototype chain when copying objects</a></em></p>

<p>コピー元オブジェクトの prototype をコピー先オブジェクトに適用するように <code>angular.copy</code> を変更しています。以前はプロトタイプチェーンのプロパティを直接コピーしていました。</p>

<p>コピー先オブジェクトの <code>hasOwnProperty</code> プロパティだけを iterate しても、prototype からのプロパティは含まれなくなり、より適切な振る舞いになっていると考えています。</p>

<p>もしアプリケーションがこの振る舞いに依存している場合は、オブジェクト（と継承プロパティ）のすべてのプロパティを <code>hasOwnProperty</code> でフィルタしないように iterate してください。</p>

<p><strong>この変更は IE 8 で動作しない機能を使っていることに注意してください。</strong>もし IE 8 で動作させたい場合は <code>Object.create</code> と <code>Object.getPrototypeOf</code> の polyfill を使ってください。</p>

<h3>core</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/bdfc9c02d021e08babfbc966a007c71b4946d69d">drop the toBoolean function</a></em></p>

<p><code>f</code> <code>0</code> <code>false</code> <code>no</code> <code>n</code> <code>[]</code> は falsy として扱われず、JavaScript の falsy 値である <code>false</code> <code>null</code> <code>undefined</code> <code>NaN</code> <code>0</code> <code>""</code> のみ falsy として扱われるようになりました。</p>

<h3>$compile</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/2cde927e58c8d1588569d94a797e43cdfbcedaf9">always error if two directives add isolate-scope and new-scope</a></em></p>

<p>1 つの要素に isolate scope と別の scope をリクエストするとエラーとなるように変更されました。変更前は、isolate でない scope の directive の次に、isolate な scope の directive という順でコンパイラが適用する場合には、2 つの directive が child scope と isolate scope をリクエストすることが可能でした。</p>

<p>順番にかかわらず、コンパイラはエラーとするようになりました。</p>

<p><code>$compile:multidir</code> エラーとなるようであれば、同じ要素で複数の directive が isolate と isolate でない scope をリクエストしていないかを確認し、コードを修正してください。</p>

<h3>NgModel</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/1be9bb9d3527e0758350c4f7417a4228d8571440">ensure pattern and ngPattern use the same validator</a></em></p>

<p>ng-pattern (<code>ng-pattern="exp"</code>) あるいは pattern 属性 (<code>pattern=""</code>) で angular 式が使われて文字列として評価される場合、validator は正規表現オブジェクトのリテラル (<code>/abc/i</code>) として文字列を解析せず、文字列全体を正規表現としてしまいます。つまり、フラグが正規表現として正しく扱われません。この制限を回避するために、正規表現オブジェクトを angular 式の値に使用してください。</p>

<p>``` javascript
// before
$scope.exp = &lsquo;/abc/i&rsquo;;</p>

<p>// after
$scope.exp = /abc/i;
```</p>

<h3>Scope</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/8c6a8171f9bdaa5cdabc0cc3f7d3ce10af7b434d">change Scope#id to be a simple number</a></em></p>

<p>Scope#$id は文字列ではなく数値型となりました。この id は主にデバッグ目的で利用されており、他に影響を与えないものと考えています。</p>

<h3>forEach</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/55991e33af6fece07ea347a059da061b76fc95f5">cache array length</a></em></p>

<p>forEach は配列の初期数だけ iterate するようになり、iteration 中に配列に追加されたアイテムは forEach の対象となりません。</p>

<p>この変更により、forEach が Array#forEach の動作により近くなりました。</p>

<h3>jqLite</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/a196c8bca82a28c08896d31f1863cf4ecd11401c">data should store data only on Element and Document nodes</a></em></p>

<p>テキスト／コメントのノードにも jqLite のデータをセットできていましたが、jQuery と同じように要素とドキュメントのノードのみとなりました。</p>

<h3>$resource</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/d3c50c845671f0f8bcc3f7842df9e2fb1d1b1c40">allow props beginning with $ to be used on resources</a></em></p>

<p><code>$resource</code> がプロパティを削除する挙動を期待している場合、手動で行う必要があります。</p>

<h3>angular.toJson</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/c054288c9722875e3595e6e6162193e0fb67a251">only strip properties beginning with $$, not $</a></em></p>

<p><code>toJson</code> がプロパティを削除する挙動を期待していた場合、手動で行う必要があります。</p>

<h3>$compile</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/eec6394a342fb92fba5270eee11c83f1d895e9fb">deprecate <code>replace</code> directives</a></em></p>

<p>要素を置き換える directive 定義の <code>replace</code> フラグは、Angular の次のメジャーバージョンで廃止されます。この機能は扱いにくい問題（属性をどのようにマージするか、など）があり、この機能が解決できることよりも多くの問題をもたらしています。また、Web Components では DOM にカスタム要素が存在するのが一般的です。</p>

<h3>$parse</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/fa6e411da26824a5bae55f37ce7dbb859653276d">remove deprecated promise unwrapping</a></em></p>

<p>promise をアンラップする機能は 1.2.0-rc.3 で既に削除されています。</p>

<h3>Scope</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/82f45aee5bd84d1cc53fb2e8f645d2263cdaacbc">$broadcast and $emit should set event.currentScope to null</a></em></p>

<p><code>$broadcast</code> と <code>$emit</code> は、イベントの伝播 (propagation) を終了した時点でイベントの <code>currentScope</code> プロパティを null にリセットするようになりました。<code>currentScope</code> プロパティに非同期にアクセスするコードは、<code>targetScope</code> を利用するようにしてください。</p>

<h3>jqLite</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/d71dbb1ae50f174680533492ce4c7db3ff74df00">stop patching individual jQuery methods</a></em></p>

<p>jQuery の <code>detach()</code> メソッドは <code>$destroy</code> イベントをトリガーしなくなりました。要素に付けた Angular データを破棄したい場合は <code>remove()</code> を利用してください。</p>

<h3>$http</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/ad4336f9359a073e272930f8f9bcd36587a8648f">remove deprecated responseInterceptors functionality</a></em></p>

<p>これまでは response interceptor を以下のようにも登録できました。</p>

<p>``` javascript
// register the interceptor as a service
$provide.factory(&lsquo;myHttpInterceptor&rsquo;, function($q, dependency1, dependency2) {
  return function(promise) {</p>

<pre><code>return promise.then(function(response) {
  // do something on success
  return response;
}, function(response) {
  // do something on error
  if (canRecover(response)) {
    return responseOrNewPromise
  }
  return $q.reject(response);
});
</code></pre>

<p>  }
});</p>

<p>$httpProvider.responseInterceptors.push(&lsquo;myHttpInterceptor&rsquo;);
```</p>

<p>v1.1.4（4ae46814）で導入された API では以下のようになります。</p>

<p>``` javascript
$provide.factory(&lsquo;myHttpInterceptor&rsquo;, function($q) {
  return {</p>

<pre><code>response: function(response) {
  // do something on success
  return response;
},
responseError: function(response) {
  // do something on error
  if (canRecover(response)) {
    return responseOrNewPromise
  }
  return $q.reject(response);
}
</code></pre>

<p>  };
});</p>

<p>$httpProvider.interceptors.push(&lsquo;myHttpInterceptor&rsquo;);
```</p>

<p>この API の詳細は <a href="https://docs.angularjs.org/api/ng/service/$http#interceptors">interceptors</a> で確認してください。</p>

<h3>injector</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/c0b4e2db9cbc8bc3164cedc4646145d3ab72536e">invoke config blocks for module after all providers</a></em></p>

<p>config ブロックは provider 登録の前に呼び出されていたため動作を制御可能でしたが、常に config よりも前に provider 登録されるようになったために動作を制御できなくなりました。</p>

<p>例：</p>

<p>以前は、以下のようなコードが動作していました。</p>

<p>``` javascript
angular.module(&lsquo;foo&rsquo;, [])
.provider(&lsquo;$rootProvider&rsquo;, function() {
  this.$get = function() { &hellip; }
})
.config(function($rootProvider) {
  $rootProvider.dependentMode = &ldquo;B&rdquo;;
})
.provider(&lsquo;$dependentProvider&rsquo;, function($rootProvider) {
  if ($rootProvider.dependentMode === &ldquo;A&rdquo;) {</p>

<pre><code>this.$get = function() {
  // Special mode!
}
</code></pre>

<p>  } else {</p>

<pre><code>this.$get = function() {
  // something else
}
</code></pre>

<p>  }
});
```</p>

<p><code>$rootProvider</code> と <code>$dependentProvider</code> の間にある config ブロックがアプリケーションの動作を変更できていましたが、これは今では 1 つのモジュール内では実現できなくなりました。</p>

<h3>ngModelOptions</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/adfc322b04a58158fb9697e5b99aab9ca63c80bb">move debounce and updateOn logic into NgModelController</a></em></p>

<p>このコミットは <code>NgModelController</code> の API を変更しています。</p>

<ul>
<li><code>$setViewValue(value)</code> &ndash; このメソッドは <code>$viewValue</code> を変更しますが、これまでとは異なり、<code>$modelValue</code> の変更をすぐにはコミットしなくなり、関連する <code>ngModelOptions</code> directive で指定されたトリガーによってコミットされるようになりました。<code>ngModelOptions</code> に <code>debounce</code> で遅延させるトリガーが指定されている場合には、変更のコミットはさらに延期されます。</li>
<li><code>$cancelUpdate()</code> &ndash; <code>$rollbackViewValue()</code> に名前が変更されましたが、同じ機能のままで、<code>$viewValue</code> の値を <code>$lastCommittedViewValue</code> に戻し、ペンディング中の debounce されている更新と、input への再 render の処理をキャンセルします。</li>
</ul>


<p><code>$cancelUpdate()</code> を利用しているコードは、以下の例に従って移行してください。</p>

<p>前：</p>

<p>``` javascript
$scope.resetWithCancel = function (e) {
  if (e.keyCode == 27) {</p>

<pre><code>$scope.myForm.myInput1.$cancelUpdate();
$scope.myValue = '';
</code></pre>

<p>  }
};
```</p>

<p>後：</p>

<p>``` javascript
$scope.resetWithCancel = function (e) {
  if (e.keyCode == 27) {</p>

<pre><code>$scope.myForm.myInput1.$rollbackViewValue();
$scope.myValue = '';
</code></pre>

<p>  }
}
```</p>

<h3>$interpolate</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/88c2193c71954b9e7e7e4bdf636a2b168d36300d">split .parts into .expressions and .separators</a></em></p>

<p><code>$interpolate</code> に返される function は <code>.parts</code> 配列を持たなくなりました。</p>

<p>代わりに、2 つの配列を持つようになります。</p>

<ul>
<li><code>.expressions</code> &ndash; interpolate されるテキストの expression 配列。</li>
<li><code>.separators</code> &ndash; interpolation 間を区切る文字列の配列で、この配列はマージしやすくするために、<strong>常に</strong> <code>.expressions</code> 配列より 1 アイテム長くなっています。</li>
</ul>


<h3>$animate</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/1cb8584e8490ecdb1b410a8846c4478c6c2c0e53">insert elements at the start of the parent container instead of at the end</a></em></p>

<p><code>$animate</code> は、親コンテナの最後の要素とする after パラメータをデフォルトとしなくなり、after が指定されていない場合には新しい要素を最初の子要素として挿入するようになりました。</p>

<p>既存のコードを更新する場合には、<code>$animate.enter()</code> または <code>$animate.move()</code> のすべてのインスタンスを</p>

<p><code>$animate.enter(element, parent);</code></p>

<p>から</p>

<p><code>$animate.enter(element, parent, angular.element(parent[0].lastChild));</code></p>

<p>に変更してください。</p>

<p><em><a href="https://github.com/angular/angular.js/commit/1bebe36aa938890d61188762ed618b1b5e193634">make CSS blocking optional for class-based animations</a></em></p>

<p>トランジションを利用する（class-add や class-remove のような）セットアップ CSS class ベースのアニメーションコードは、スタイルがすぐに適用されるように空の transition 値を与えなければなりません。つまり、アニメーションのコードがセットアップ class で定義されているスタイルを適用し、その CSS class で <code>transition:0s none</code> の値が存在しない限りは即座に適用されません。この状況はトランジションがベース CSS クラスに存在し、アニメーションが開始されているケースのことです。</p>

<p>前：</p>

<p><code>css
.animated.my-class-add {
  opacity:0;
  transition:0.5s linear all;
}
.animated.my-class-add.my-class-add-active {
  opacity:1;
}
</code></p>

<p>後：</p>

<p><code>css
.animated.my-class-add {
  transition:0s linear all;
  opacity:0;
}
.animated.my-class-add.my-class-add-active {
  transition:0.5s linear all;
  opacity:1;
}
</code></p>

<p>詳細は ngAnimate のドキュメントで確認してください。</p>

<h3>$compile</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/299b220f5e05e1d4e26bfd58d0b2fd7329ca76b1">add support for $observer deregistration</a></em></p>

<p><code>attr.$observe</code> の呼び出しはオブザーバー function ではなく、登録解除の function を返すようになりました。以下の例に従ってコードを移行してください。</p>

<p>前：</p>

<p>``` javascript
directive(&lsquo;directiveName&rsquo;, function() {
  return {</p>

<pre><code>link: function(scope, elm, attr) {
  var observer = attr.$observe('someAttr', function(value) {
    console.log(value);
  });
}
</code></pre>

<p>  };
});
```</p>

<p>後：</p>

<p>``` javascript
directive(&lsquo;directiveName&rsquo;, function() {
  return {</p>

<pre><code>link: function(scope, elm, attr) {
  var observer = function(value) {
    console.log(value);
  };

  attr.$observe('someAttr', observer);
}
</code></pre>

<p>  };
});
```</p>

<h3>$httpBackend</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/6680b7b97c0326a80bdccaf0a35031e4af641e0e">don&rsquo;t error when JSONP callback called with no parameter</a></em></p>

<p>空のレスポンスに対する JSONP の動作が変更されました。以前は JSONP レスポンスが空の場合にはエラーとみなされていましたが、適切にイベントをリスンするようになりました。</p>

<h3>build</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/eaa1d00b24008f590b95ad099241b4003688cdda">remove IE8 target from all test configs</a></em></p>

<p>IE 8 はサポートされなくなりました。</p>

<h3>input</h3>

<p><em><a href="https://github.com/angular/angular.js/commit/46bd6dc88de252886d75426efc2ce8107a5134e9">support types date, time, datetime-local, month, week</a></em></p>

<p>type が date、time、datetime-local、month、week の input では、モデルとして常に <code>Date</code> オブジェクトが必須となりました。</p>
]]></content>
  </entry>
  
</feed>
